// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Belt_MapInt = require("bs-platform/lib/js/belt_MapInt.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");

function stringOfSquareValue(value) {
  switch (value) {
    case 0 : 
        return "";
    case 1 : 
        return "X";
    case 2 : 
        return "O";
    
  }
}

function Game$Square(Props) {
  var onClick = Props.onClick;
  var value = Props.value;
  return React.createElement("button", {
              className: "square",
              onClick: onClick
            }, stringOfSquareValue(value));
}

var Square = /* module */[/* make */Game$Square];

function Game$Board(Props) {
  var onClick = Props.onClick;
  var squareValues = Props.squareValues;
  return Belt_Array.map(/* array */[
              0,
              1,
              2
            ], (function (row) {
                return React.createElement("div", {
                            key: String(row),
                            className: "board-row"
                          }, Belt_Array.map(/* array */[
                                0,
                                1,
                                2
                              ], (function (col) {
                                  var squareIndex = Caml_int32.imul(3, row) + col | 0;
                                  return React.createElement(Game$Square, {
                                              onClick: (function (evt) {
                                                  return Curry._2(onClick, evt, squareIndex);
                                                }),
                                              value: Belt_MapInt.getWithDefault(squareValues, squareIndex, /* SquareEmpty */0),
                                              key: String(squareIndex)
                                            });
                                })));
              }));
}

var Board = /* module */[/* make */Game$Board];

function calculateWinner(squareValues) {
  var checkLine = function (param) {
    var v1 = Belt_MapInt.getWithDefault(squareValues, param[0], /* SquareEmpty */0);
    var v2 = Belt_MapInt.getWithDefault(squareValues, param[1], /* SquareEmpty */0);
    var v3 = Belt_MapInt.getWithDefault(squareValues, param[2], /* SquareEmpty */0);
    if (v1 === /* SquareX */1 && v2 === v1 && v3 === v1) {
      return /* SquareX */1;
    } else if (v1 === /* SquareO */2 && v2 === v1 && v3 === v1) {
      return /* SquareO */2;
    } else {
      return /* SquareEmpty */0;
    }
  };
  return Belt_Option.getWithDefault(Belt_List.head(Belt_List.keep(Belt_List.map(/* :: */[
                          /* tuple */[
                            0,
                            1,
                            2
                          ],
                          /* :: */[
                            /* tuple */[
                              3,
                              4,
                              5
                            ],
                            /* :: */[
                              /* tuple */[
                                6,
                                7,
                                8
                              ],
                              /* :: */[
                                /* tuple */[
                                  0,
                                  3,
                                  6
                                ],
                                /* :: */[
                                  /* tuple */[
                                    1,
                                    4,
                                    7
                                  ],
                                  /* :: */[
                                    /* tuple */[
                                      2,
                                      5,
                                      8
                                    ],
                                    /* :: */[
                                      /* tuple */[
                                        0,
                                        4,
                                        8
                                      ],
                                      /* :: */[
                                        /* tuple */[
                                          2,
                                          4,
                                          6
                                        ],
                                        /* [] */0
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ], checkLine), (function (v) {
                        return v !== /* SquareEmpty */0;
                      }))), /* SquareEmpty */0);
}

function hasWinner(squareValues) {
  return calculateWinner(squareValues) !== /* SquareEmpty */0;
}

function nextMove(state, squareIndex) {
  console.log("squareIndex " + String(squareIndex));
  if (Belt_MapInt.getWithDefault(state[/* squareValues */0], squareIndex, /* SquareEmpty */0) !== /* SquareEmpty */0 || calculateWinner(state[/* squareValues */0]) !== /* SquareEmpty */0) {
    return state;
  } else if (state[/* xIsNext */1]) {
    return /* record */[
            /* squareValues */Belt_MapInt.set(state[/* squareValues */0], squareIndex, /* SquareX */1),
            /* xIsNext */false
          ];
  } else {
    return /* record */[
            /* squareValues */Belt_MapInt.set(state[/* squareValues */0], squareIndex, /* SquareO */2),
            /* xIsNext */true
          ];
  }
}

function initEmptySquareValues(param) {
  var __x = Belt_Array.make(9, /* SquareEmpty */0);
  return Belt_MapInt.fromArray(Belt_Array.mapWithIndex(__x, (function (index, value) {
                    return /* tuple */[
                            index,
                            value
                          ];
                  })));
}

function Game(Props) {
  Props.message;
  var match = React.useReducer((function (state, action) {
          return nextMove(state, action[0]);
        }), /* record */[
        /* squareValues */initEmptySquareValues(/* () */0),
        /* xIsNext */true
      ]);
  var dispatch = match[1];
  var state = match[0];
  var handleClick = function (_event, squareIndex) {
    return Curry._1(dispatch, /* NextMove */[squareIndex]);
  };
  var winner = calculateWinner(state[/* squareValues */0]);
  var statusDisplay = winner !== /* SquareEmpty */0 ? "Winner: " + stringOfSquareValue(winner) : "Next player: " + (
      state[/* xIsNext */1] ? "X" : "O"
    );
  return React.createElement("div", {
              className: "game"
            }, React.createElement("div", {
                  className: "game-board"
                }, React.createElement(Game$Board, {
                      onClick: handleClick,
                      squareValues: state[/* squareValues */0]
                    })), React.createElement("div", {
                  className: "game-info"
                }, React.createElement("div", undefined, statusDisplay)));
}

var make = Game;

exports.stringOfSquareValue = stringOfSquareValue;
exports.Square = Square;
exports.Board = Board;
exports.calculateWinner = calculateWinner;
exports.hasWinner = hasWinner;
exports.nextMove = nextMove;
exports.initEmptySquareValues = initEmptySquareValues;
exports.make = make;
/* react Not a pure module */
